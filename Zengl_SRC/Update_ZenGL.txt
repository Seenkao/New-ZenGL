ZenGL 3.29

Добавлено:
- процедура сброса таймера. zgl_Reg(SYS_RESET, @gameReset) - задействована для режима паузы. Если вы работаете с физикой и с точным временем.
- добавлены прорисовываемые примитивы. Циклическая или ломанная линии pr2d_LineSORL (Strip or Loop line). Треугольник pr2d_Triangle. Произвольный четырёхугольник pr2d_quad.
- добавлена функция пересечения двух прямоугольников (вертикальных или горизонтальных) по двум точкам col2d_RectBPEP (Begin point - End point).

- добавлены комментарии и переводы к ним.

Green Engine:
- модуль gegl_Color - для ускоренной работы с цветом. Используется в основном для примитивов zgl_primitives_2d. Все значения 
- в поле ввода добавлены ограничивающие функции. Так же есть возможность создать самим ограничивающие функции.

Работа с экраном:
- добавлена функция для установки дальности прорисовки для 2D - Set2DNearFar. И объекты можно располагать по "глубине" экрана (по координате Z). При включении теста глубины, дальние объекты будут перекрыты ближними (на данное время не проверял). Эту функцию можно использовать и для 3D, но учитывать что Near не должно быть меньше нуля.
- при включении/выключении флага DEPTH_BUFFER (zgl_Enable/zgl_Disable), включается очистка GL_DEPTH_BUFFER_BIT. Что позволяет правильно работать с проверкой глубины "https://www.opengl.org/archives/resources/faq/technical/depthbuffer.htm" - для ознакомления.
- в функциях zgl_Enable и zgl_Disable добавлен флаг XY_IN_CENTER_WINDOW. При его включении X = 0, Y = 0 будут в центре экрана. (внимание, процедуры прорисовки примитивов не перерабатывались под данный флаг, потому может быть смещение примитивов на 1 пиксель при прорисовке).

OpenGL
- добавлены процедуры OpenGL для работы с дисплейными списками. Так же добавлены функции для работы с буферами в минимальную версию OpenGL.
- добавлен модуль "zgl_GLX_WGL.pas" и отделены функции из модуля "zgl_opengl_all.pas" для работы с GLX и WGL. Всё обновлено в соответствии с окончанием 2021-го года, за исключением определённых заголовков.
- добавлен модуль "zgl_GLU.pas", отделены функции из модуля "zgl_opengl_all.pas" для работы с GLU.
- добавлен модуль "zgl_pasOpenGL.pas". Он обновлён согласно последним изменениям на конец 2021 года (возможны ошибки, требуется тестирование). По умолчанию включен минимальный набор OpenGL спользуемый в ZenGL.
- добавлен файл конфигурации для модулей "zgl_GLX_WGL.pas", "zgl_pasOpenGL.pas" - "GLdefine.cfg" и файл с константами и типами "zgl_gltypeconst.pas".
- добавлена процедура procedure "SetGLVersionAndFlags({$IfNDef MAC_COCOA}major, minor: Integer; flag: LongWord = COMPATIBILITY_VERSION{$Else}mode: LongWord{$EndIf});" для Linux и Windows введена возможность создания контекста для OpenGL 3+ (в MacOS она была сразу, изменено название).

- многие типы перенесены в модуль zgl_types.
- структуры разделены на 2D и 3D. И примитивы так же разделены на 2D и 3D. Точнее в конце структур/примитивов они добавлены - изменения не значительны (как пример: zglTRect -> zglTRect2D).

Изменено:
- для таймеров изменены рабочие константы на t_Start, t_SleepToStart, t_Stop, t_SleepToStop. Во избежание случайных совпадений.
- для мыши возращены изначальные функции и константы (работа функций не изменена), для совместимости и удобства.
- для тачпада тоже изменено, но не проверено.

Недоработки!
Проблемы работы когда у вас два монитора. Как на Linux, так и на Windows.
Windows 10: решить проблему с перетаскиванием LCL-окна с одного монитора на другой. Проблема в том, что приложение полностью зависает. В данное время проблема отложена в "долгий ящик". Если знаете способ решения, то можете предложить. Проблема исходит из того, что событие Draw забивает очередь LCL-приложения и приложение зависает.
Linux: решить проблему при переключении разрешений экрана. Используется XRandr - поэтому надо делать проверку на количество мониторов и местоположение на мониторе. Полноэкранный режим - это окно для двух мониторов? Или особое свойство работы XRandr? Поиск решения проблемы отложен.

------------------------------------------------------------------------------------------
Изменения в версии 3.28.
- Добавлена библиотека Green Engine собственной разработки. Это вроде как дополнительное API для библиотеки ZenGL. Разрабатывалась ранее и клавиатура из Green Engine была добавлена в более ранние версии. Внимание!!! Работает только с ZenGL!!!
    - В данной версии GE создано независимое от платформы поле ввода. Должно работать на всех платформах, но на мобильных платформах и MacOS не проверено. Будет проверено и добавлено в исправления.

    - В дальнейшем ожидается доработка библиотеки GE.

- изменены названия малой части процедур/функций, для более визуального восприятия. В частности utf8_GetID заменена на utf8_toUnicode так как она как раз переводит UTF8 в юникод.

- добавлена функция function Unicode_toUTF8(Symb: LongWord): UTF8String; перевода из юникода в UTF8.

- изменена и ускорена работа с текстом.
    - теперь вы не получите ошибку кода, если символа не существует при загруженном шрифте. Все не существующие символы будут отмечены знаком "?".
    - вы сможете писать на любом языке, но, если шрифт для этого не предназначен, все "не печатаемые" (не определённые в шрифте) символы будут так же отмечены знаком "?". При сохранинии такого текста в файл, вероятнее всего он будет выведен правильно.
    - в демонстрационной версии 6, показана работа со шрифтами. Если вам нужен шрифт определённого размера, вы должны с ним работать через procedure setFontTextScale(Index: LongWord; fnt: Byte);, она позволит вам более быстро работать с данным шрифтом. Если не постоянно, то смотрите демонстрационную версию.
    - дополнен ряд функций для работы с текстом-шрифтами. Смотрите в файле zgl_text.pas.
    - созданы процедуры для загрузки/сохранения текста procedure txt_LoadFromFile(const FileName: UTF8String; out Buf: UTF8String);, procedure txt_SaveFromFile(const FileName: UTF8String; const Buf: UTF8String);.

- были исправлены некоторые ошибки в коде и изменены части работы с клавиатурой. keysLast (bold) - сейчас работает только для печатаемых клавиш.

- введена процедура постотрисовки. Регистрируется с помощью zgl_Reg и флагом SYS_POSTDRAW. Срабатываете данная функция только после того как выведется всё в окно. Бывает нужно, когда нужно работать с видеокартой, но не нужно ни чего выводить.

- теперь обработка клавиатуры/мыши/тачпада необходимо производить с помощью регистрируемой процедуры и флагом SYS_EVENTS. Производить их "очистку" больше  нет необходимости.
- добавленны комментарии в некоторые модули. Постарался сразу же добавить и на английском языке.

- были исправления в части кода, о которых уже забыл... )))
